---
layout: default
title: node模块加载原理
description: node模块（module）加载原理
categories: [node]
tags: [module]
---
# {{ page.title }}

## 1 js模块概述
历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。这对开发大型的、复杂的项目形成了巨大障碍。

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。

## 2 node模块语法
我们来写1个a模块---a.js，代码如下
```javascript
// a.js - node中一个文件就是一个模块

// 导出 'hello'
module.exports = 'hello'

```

再写个useA模块，useA中应用a模块的内容
```javascript
// useA.js - 应用a模块的内容

const a = require('./a.js');
console.log(a);
```

## 3 node模块加载的原理
我们定义a模块的时候，node内部把我们的a模块包装了一层函数，代码如下：
```javascript
// a.js - node处理后的
// module.exports = 'hello'
(fucntion () {
    module.exports = 'hello'
    return module.exports
})

```

在useA模块应用a模块的时候，node会把包装为函数的内容读到（node可以在服务端读写文件），然后执行一下，代码如下：
```javascript
// useA.js - 读取a模块的内容并执行

const a = (fucntion () {
    module.exports = 'hello'
    return module.exports
})();
console.log(a);

```

## 4 更多代码查看下面链接
[https://github.com/happychong/2019-zhufeng/tree/master/2.nodeModule](https://github.com/happychong/2019-zhufeng/tree/master/2.nodeModule)
