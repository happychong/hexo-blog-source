---
layout: default
title: Vue 面试题
description: Vue 面试题
categories: [Vue]
tags: [面试题]
---
# {{ page.title }}

## 1 请说下对MVVM的理解

MVVM：model + view + viewModel

MVC：model + view + control

## 2 Vue 实现数据双向绑定的原理

Object.defineProperty [点击查看更多代码]()

## 3 Vue 常用的指令有哪些？

v-once 、 v-html 、 v-bind 、 v-for 、 key 、 v-if / else 、 v-if 、 v-show 、 v-on 、 v-model 

## 4 v-model 的原理

:value + @input

## 5 v-if 和 v-show 的区别

v-if：dom是否创建

v-show：dom是否在界面中可见 style

## 6 Vue 中 key 值的作用

更新视图，key要保证唯一性

## 7 computed 和 watch 有什么区别？

## 8 Vue 的生命周期，每个生命周期具体适合哪些场景？
create  beforeCreate：
          初始化好了基础属性，基础事件（$on $emit 等），
          不包含vm的数据(data)、方法、watch等，所以基本上业务逻辑不需要使用这个钩子，
          混合 - 如希望在每个组件中增加一些特定的属性，可以采用这个钩子
        created：
          创建完成 - 当前这个组件实例，已经实现了数据劫持（数据已经加了get，set），
          并把方法、计算属性都挂载到了实例上
          但是不能获取到真是的dom元素，不能操作dom
Mount   beforeMount：
          挂载之前，方法中会调用render方法
        mounted：
          当前组件挂载完成 - 有了真实的dom，
          这个过程中，如果有子组件，会走子组件的生命周期，洋葱模式，
          一般把ajax的操作，在这里完成，既能得到vm数据，又有$el方便操作。
Update  beforeUpdate：
          更新之前 - Vue的更新是diff更新，需要更新的数据在视图中显示，才会触发beforeUpdate
        updated：
          更新完成，这里不要再更新数据，可能会死循环。
Destroy beforeDestroy：
          销毁之前 - 可以做事件移除 清空定时器等。
        destroyed：
          销毁后

触发销毁的方式：- 销毁后会默认移除所有观察者，移除监听事件（watcher.active = false），视图并不会刷新
  1-手动移除组件（vm.$destroy()）
  2-路由切换

 
## 9 Vue 中 ref 是什么？
组件上是vue组件，dom上指dom元素，for循环出来的是类数组

## 10 Vue 动画的生命周期？
.v-enter  /* 进入前 */
.v-enter-active /* 进入中 这里写颜色会立刻替换掉v-leave中的颜色*/
.v-enter-to /* 进入后 */
.v-leave /* 要离开的时候，会立刻替换掉之前的颜色 */
.v-leave-active /* 离开时 这里写颜色会立刻替换掉v-leave中的颜色 */
.v-leave-to /* 离开后 */

## 11 Vue 如何编写自定义指令？

```javascript
// 全局指令
  // 设置方法1 = 设置方法2中只有 bind 和 update 的语法糖
  Vue.directive('focus1', function (el, bindings, vNode) {
    // el - 当前指令元素
    // bindings - 绑定属性（修饰符-modifiers、表达式-expression、value等）
    // vNode - 虚拟节点 有context属性代表当前指令的上下文

    // 这个方法默认只在 bind（绑定）的时候和 update(更新-当前指令依赖的数据变化)的时候才会被执行
    console.log(el, bindings, vNode);
    el.focus(); // 没效果 因为页面还没初始化好el这个dom节点 应该插入dom之后再执行focus方法，如inserted中
  });
  // 设置方法2
  Vue.directive('focus2', {
    // 指令的触发周期顺序(最常用的) bind -> inserted -> update -> unbind
    // bind (el, bindings, vNode) {
    //   console.log(el, bindings, vNode);
    //   el.focus();
    //   // 可以用 nextTick 实现 inserted 效果
    // },
    // update (el, bindings, vNode) {
    //   console.log(el, bindings, vNode);
    //   el.focus();
    // },
    inserted(el, bindings, vNode) {
      // 插入（初始化）dom之后执行此方法
      // 指令 focus2 中，有修饰符color的，把dom边框变成设置的颜色
      if (bindings.modifiers.color) {
        el.style.borderColor = bindings.value;
      }
      el.focus(); // focus2 指令的元素自动获取焦点
    },
    unbind() {
      // 指令小会的时候 会触发此函数
    }
  });
```

```vue
<!-- Vue clickOutside指令 -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vue clickOutside指令</title>
  <style>
    .input { border: 1px solid red;}
    .content { background-color: bisque;}
  </style>
</head>
<body>
  <div id="app">
    日历控件 | 弾层 ： 
    <div v-click-outside>
      <input type="text" class="input"/>
      <div v-if="isShow" class="content">
        内容
        <button>加载更多内容</button>
      </div>
    </div>
  </div>
  <script src="./node_modules/vue/dist/vue.js"></script>
  <script>

    let vm = new Vue({
      el: '#app',
      directives: {
        // 局部指令 只当前vm有效
        clickOutside:{
          // 可以实现 点击时判断是否存在当前dom中
          bind(el, bindings, vNode) {
            el.fn = (e) => {
              if (el.contains(e.target)) {
                vNode.context.showContent();
              } else {
                vNode.context.hideContent();
              }
            };
            document.addEventListener('click', el.fn);
          },
          unbind(el) {
            // 事件绑定必须要解绑
            document.removeEventListener('click', el.fn);
          }
        }
      },
      data: {
        isShow: false
      },
      methods: {
        showContent() {
          this.isShow = true;
        },
        hideContent() {
          this.isShow = false;
        }
      },
    })
  </script>
</body>
</html>
```

## 12 vuex 是什么？

vuex是vue的状态管理工具，为了更方便实现多个组件共享状态。

state 状态  ， mutation 同步更新状态， action 异步更新状态

## 13 vuex数据持久化

用插件（vuex-persists）解决

plugins---plugins就是函数，参数会默认传当前的store实例

```javascript
const persists = (store) => {
  // subscribe - 订阅 commit的时候会触发
  store.subscribe((mutation, state) => {
    // 这里可以把需要记录的值存到localStotage，然后页面初始化的时候再取值，初始化
    console.log(mutation);
  })
}

new Vuex.Store({
  plugins: [ persists ],
  modules: {},
  state: {
    a: 1
  },
  getters: {},
  mutations: {}
})
```

## 14 移动端项目

### 单位

px (不能跟随屏幕大小而改变)
em (不好计算)
rem (主流)
vh vw (主流)

淘宝解决方案：px2rem 插件解决（可以把px 转化成rem，开发中只写px就好）

```
npm i lib-flexible --save 
npm install --save-dev px2rem-loader
```

```javascript
// 使用 main.js中引入
import 'lib-flexible/flexible'
```

```javascript
// 配置 vue.config.js

module.exports= {
  chainWebpack: config => {
    config.module.rule('stylus').test(/\.stylus/).oneOf('vue')
    .resourceQuery(/\?vue/).use('px2rem').loader('px2rem-loader').options({remUnit: 75})
  }
}
```

### 布局 flex

* flex-direction  :  row / row-reverse column / column-reverse
* flex-wrap : nowrap(默认) / wrap 
* justify-content : 主轴对齐方式 flex-start flex-end center space-between space-around
* align-items : 设置交叉轴的对齐方式 flex-start flex-end center baseline stretch
* align-content : 轴线对齐方式 多行对齐方式 flex-start flex-end center stetch space-between space-around
* order : 控制元素顺序 默认0 可以设置元素的顺序
* flex-grow : 控制元素放大比例
* flex-shrink : 控制元素缩小比例
* flex-basis : 设置元素固定空间或自动空间的占比
* align-self : 重写align-items父属性

## 主流组件库

### pc

elementUI iview

### 移动端的ui组件

vant mint-ui(官方不维护了) and-vue vube-ui(滴滴出的)
