---
layout: default
title: webpack 4.0 + 笔记(优化)
description: webpack
categories: [周边]
tags: [webpack]
---
# {{ page.title }}

## 前言

代码地址：[https://github.com/happychong/2019-zhufeng/tree/master/9.webpack](https://github.com/happychong/2019-zhufeng/tree/master/9.webpack)

查看此文档打包前提：

1. webpack.base.js 中 entry 设置为 index-optimize.js
2. .babelrc -> presets -> @babel/preset-typescript 关于 typescript 的部分设置注释掉

## 一：删除无用css代码

```bash
# 安装包
npm install purgecss-webpack-plugin glob --save-dev
```

```javascript
// webpack 配置文件
const glob = require('glob'); // 查找匹配的文件
// 删除无意义的css，只能配合mini-css-extract-plugin
const PurgeCssWebpackPlugin = require('purgecss-webpack-plugin');
// 配置对象
{
    plugins: [
        new PurgeCssWebpackPlugin({
            // glob.sync: 返回包含 src 目录下所有（深层）文件的文件名的数组, nodir-不包含目录名
            paths: glob.sync("./src/**/*", { nodir: true })
        })
    ]
}
```

## 二：图片压缩  image-webpack-loader

必须要和 file-loader 一起使用，相当于先优化再拷贝

```bash
# 安装包
npm install image-webpack-loader --save-dev
```

```javascript
// webpack 配置文件
{
    module: {
        rules: [{
            test: /\.(jpe?g|png|gif)$/,
            use: [
                {
                    loader: 'url-loader',
                    // 希望当前比较小的图片转化为 base64 ，转化后尺寸比以前大，但是不用发http请求了
                    options: {
                        // 大于 100k 的图片，会用 file-loader
                        limit: 8 * 1024, // 一般为 8*1024
                        // 打包到目录下
                        name: 'image/[contentHash].[ext]'
                    }
                },
                (!isDev) && {
                    // 可以在使用file-loader之前 对图片进行压缩
                    loader: 'image-webpack-loader',
                    options: {
                        // jpeg格式
                        mozjpeg: {
                            progressive: true,
                            quality: 65
                        },
                        // optipng.enabled: false will disable optipng
                        // 是否禁用png压缩：不禁用
                        optipng: {
                            enabled: false,
                        },
                        // png格式
                        pngquant: {
                            // 清晰度 64% - 90% 之间
                            quality: [0.65, 0.90],
                            speed: 4
                        },
                        // gif格式
                        gifsicle: {
                            interlaced: false,
                        },
                        // the webp option will enable WEBP
                        // bp格式
                        webp: {
                            quality: 75
                        }
                    }
                }
            ].filter(Boolean)
        }]
    }
}
```

## 三：cdn 资源

### externals设置外部变量

```html
<!DOCTYPE html>
<body>
    <!-- 这样引入cdn资源 -->
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
    <div id="root"></div>
    <div id="react-root"></div>
    <div id="ts-react-root"></div>
</body>
</html>
```

```javascript
// webpack 配置文件
{
    externals: {
        // 代码中，import $ 的时候，使用 $ 的时候，是外部变量，不需要被打包
        'jquery': '$'
    }
}
```

### add-asset-html-cdn-webpack-plugin 添加html资源作为cdn的webpack插件

但是如果需要cdn资源比较多，那么html文件中的script标签就会比较多，不方便，所以用  插件维护cdn资源引入

```bash
# 安装包
npm i --save-dev add-asset-html-cdn-webpack-plugin
```

```javascript
// webpack 配置文件
// 用add-asset-html-cdn-webpack-plugin的话，注释掉上面设置的externals和html中的script标签部分
// js管理cdn资源引入插件 添加html资源作为cdn的webpack插件
const AddAssetHtmlCdnWebpackPlugin = require('add-asset-html-cdn-webpack-plugin');

{
    plugins: [
        new AddAssetHtmlCdnWebpackPlugin(true, {
            'jquery': 'https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js'
        })
    ]
}
```

## tree-shaking 去掉没用的代码，只支持es6模块（webpack内置功能）

去掉没用的代码，只支持es6模块,因为es6是静态导入，可以在使用之前分析用到哪些

只在生产模式下有效

```javascript
// index-optimize.js
// calc中导出add 和 minus方法，但是这里只用了minus
// 那么npm run dev 打包包括2个方法，npm run build 只包括minus方法
import { minus } from './calc';
console.log(minus(1, 2));
```

## sideEffects - 是否应用副作用代码(生产模式有效)

```javascript
// test.js
function test() {return 'hello'}
// 模块内部执行test
console.log(test());
export default test;
```

```javascript
// index-optimize.js
import test from './test';
// 只引用test模块，并没有应用
```

以上情况下，webpack认为代码应该保留test的代码

但是实际上我们认为test模块被引入，但是引入test的模块并没有应用test模块，test这样的副作用的代码，是无意义的，打包时需要被删除掉

我们想打包的时候删除这样的副作用代码，需要手动在package.json中设置 sideEffects: false

```javascript
// package.json
{
    // 是否应用副作用
    "sideEffects": false
    // 但是这样设置之后也会有额外的影响，比如直接引入样式，生产打包的时候会被忽略掉
    // 所以用下面的设置方法
    "sideEffects": [
        // css文件，不是副作用
        "**/*.css"
    ]
}
```

## Scope-Hoisting - 减少作用域 | 并计算 （只生产模式下有效）（webpack内置功能）

每个模块都是一个函数，函数太多会导致内存过大

```javascript
// scope-Hoisting.js
let a = 1;
let b = 2;
let c = 3;
let d = a + b + c;
export default d;
```

```javascript
// index-optimize.js
import d from './scope-Hoisting';
// 导出d，打包后导出的是一个函数（消耗内存），如下
// (function () {
//     return 6
// })()
// Scope-Hoisting 会 直接导出数值6，节省内存，webpack4之后，不需要配置
console.log(d);
```

## dllPlugin - 动态链接库 ： 打包库（主要开发模式应用）

# 资料 未完成 未完成 未完成

背景1：开发模式下，每次保存代码就重新打包，每次打包都要打包react 和 react-dom 库内容，性能不高

背景2：生产模式，需要单独打包第三方模块，例如react，vue等

先把 react 和 react-dom 单独打包好，放在那，用manifest.json（缓存文件）配置好，当查找 node_modules 下的 react 和 react-dom 的时候，就从manifest.json里的配置读取

```javascript
// webpack.dll.js 打包公共模块的webpack配置文件
let path = require('path');
module.exports = {
    entry: './src/calc.js', // 其中包含 add & minus
    // entry:[]
    output: {
        filename: 'calc.js',
        path: path.resolve(__dirname, 'dll')
    }
}
// 目前是为了将calc打包成node可以使用的模块
```

```javascript
// package.json
{
    "scripts": {
        "dll": "webpack --config ./build/webpack.dll.js"
    }
}
```

## optimization -> usedExports : 打包文件提示，哪个方法未用到

```javascript
// webpack 配置文件
{
    // 优化项配置
    optimization: {
        // 开发模式下，使用了哪个模块，打包代码中提示一下
        usedExports: true
    }
}
```

```javascript
// exports used: minus : 打包结果就会提示minus被使用了
/***/ "./src/calc.js":
/*!*********************!*\
  !*** ./src/calc.js ***!
  \*********************/
/*! exports provided: add, minus */
/*! exports used: minus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {
```
