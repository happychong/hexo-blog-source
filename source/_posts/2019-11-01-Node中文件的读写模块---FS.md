---
layout: default
title: Node -文件读写模块--- fs
description: fs - 文件读写
categories: [Node]
tags: [fs]
---
# {{ page.title }}

## 一：简述

fs 模块提供了与文件系统进行交互的API，其中包括同步和异步的形式。

### 1 同步方法

- 优点：易使用
- 适用场景：刚开始启动项目时候使用
- 错误机制：文件不存在直接抛出错误

> 同步的操作发生的异常会立即抛出，可以使用 try…catch 处理，也可以允许冒泡

### 2 异步方法

- 优点：不堵塞主线程
- 适用场景：项目运行起来后使用
- 错误机制：如果文件不存在，在回调方法中的第一个参数传入错误信息 

> 异步的形式总是将完成回调作为其最后一个参数。 传给完成回调的参数取决于具体方法，但第一个参数始终预留用于异常。 如果操作成功完成，则第一个参数将为 null 或 undefined

## 二：fs 的常用方法

### 1 导入

```javascript
const fs = require('fs');
```

### 2 读取

读取文件，文件不存在的话会报错，同步、异步不同的报错形式

#### 语法：

同步：fs.readFileSync(path[, options])

异步：fs.readFile(path[, options], callback)

- path ： 文件名或文件描述符
- options ：（Object | string）
  - encoding ：（string | null） 默认值: null。
  - flag ：（string） 参阅支持的文件系统标志。默认值: 'r'。
- callback ：（Function）
  - err ：Error
  - data （string | Buffer）
  
```javascript
// 同步
const fs = require('fs');
try {
    let b = fs.readFileSync('./b.js');
    // b 是 Buffer 的二进制流
    console.log(b.toString());
} catch (err) {
    // 处理错误
    console.log('文件不存在');
}

// 异步
fs.readFile('./c.js', (err, data) => {
    if (err) {
        console.log('文件不存在');
    } else {
        console.log(data.toString());
    }
});
```

### 3 写入

写入文件，文件不存在会创建文件，不报错

#### 语法

同步：fs.writeFileSync(file, data[, options])

异步：fs.writeFile(file, data[, options], callback)

- file ：文件名或文件描述符
- data ：写入的内容
- options ：（Object | string）
  - encoding ：（string | null） 默认值: null
  - mode ：默认值: 0o666
  - flag ：（string） 文件系统标志。默认值: 'w'
- callback ：（Function）
  - err ：Error
  
```javascript
// 同步
const fs = require('fs');

fs.writeFile('文件.txt', data, (err) => {
  if (err) throw err;
  console.log('文件已被保存');
});

fs.writeFile('文件.txt', 'Node.js中文网', 'utf8', callback);
```

## 三：拷贝文件 - 扩展 (fs.open  fs.read  fs.write  fs.close)

```javascript
// 此方式不适合大文件的拷贝，否则会引发内存浪费
const fs = require('fs');
fs.readFile('./source.js', (err, data) => {
    if (err) {
        console.log('文件不存在');
    } else {
        console.log(data.toString());
        fs.writeFile('./copy.js', data, function() {
            if (err) throw err
        })
    }
});
// 这里实现的文件拷贝的功能，有性能上的问题，假如被拷贝的source.js文件非常大，有1G，那这种实现方式，需要把整个1G内容全部读取到计算机内存中，再把内存中的数据写入到copy.js中，浪费了大量的计算机的内存
```

一般项目中，64K以下的文件拷贝，应用上面的实现方式，64K以上的文件拷贝，应用下面的实现方式

相关API：

- fs.open(path[, flags[, mode]], callback)
- fs.read(fd, buffer, offset, length, position, callback)
- fs.write(fd, buffer[, offset[, length[, position]]], callback)
- fs.close(fd, callback)

```javascript
// 读一点，写一点的拷贝方式 - 手动按字节来读取
// fs.open  fs.read  fs.write  fs.close
const fs = require('fs');

let buffer = Buffer.alloc(3);
fs.open('./a.txt', 'r', (err, rfd) => {
    // fd : file descriptor 文件描述符
    fs.open('./new.txt', 'w', (err, wfd) => {
        let index = 0;
        function readFile(index, wirteLength=3) {
            fs.read(rfd, buffer, 0, 3, index, function (err, tytesRead, buffer) {
                // tytesRead 真正读取到的位置
                if (err) {
                    throw err;
                } else {
                    fs.write(wfd, buffer, 0, tytesRead, (err, written, buffer) => {
                        index += tytesRead;
                        if (tytesRead === 3) {
                            // 读取到了3个，递归读取and写入
                            readFile(index);
                        } else {
                            fs.close(wfd, () => {
                                console.log('wfd关闭');
                            });
                            fs.close(rfd, () => {
                                console.log('rfd关闭');
                            });
                        }
                    })
                }
            })
        }
        readFile(index);
    })
})
```

## 四：文件系统标志 - 常用

当 flag 选项采用字符串时，可用以下标志：

- r ： 读取 - 打开文件用于读取。如果文件不存在，则出现异常
- r+ ：在读的基础上可以写 - 打开文件用于读取和写入。如果文件不存在，则出现异常
- w ：写入 - 打开文件用于写入。如果文件不存在则创建文件，如果文件已存在则截断文件
- w+ : 在写的基础上读取 - 打开文件用于读取和写入。如果文件不存在则创建文件，如果文件已存在则截断文件